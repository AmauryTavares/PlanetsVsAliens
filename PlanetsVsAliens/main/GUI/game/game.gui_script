local gamestate = require('oyster.gamestate')
local playerdata = require('oyster.playerdata')
local oyster = require('oyster.oyster')

local handleTouch = nil
local updatePosPlanet = nil
local sendPosRoutes = nil
local sendPosPortal = nil
local loadPlanetSidebar = nil
local loadInfobar = nil

function init(self)
	msg.post('.', 'acquire_input_focus')

	self.over_board = false
	
	self.numPlanetSidebar = 5
	self.boardLine = 5
	self.boardColumn = 6
	
	self.currentPlanetIndex = nil
	self.initialPosPlanet = nil
	self.currentPlanetSelect = nil
	self.planetsSelected = oyster.get('planets_selected')

	self.currentTime = 120

	self.progressbar = gui.get_node('progressbar')
	self.scale_progressbar = gui.get_scale(self.progressbar)

	self.lb_stars = gui.get_node('lb_stars')
	self.lb_fragments = gui.get_node('lb_fragments')
	self.lb_life = gui.get_node('lb_life')
	
	sendPosRoutes(self)
	sendPosPortal(self)
	loadPlanetSidebar(self)
	loadInfobar(self, 0, 300, 100) -- stars initial, fragments initial, life initial
	gamestate.set('PLAY')
end

function update(self, dt)
	if self.currentTime > 0 then
		self.currentTime = self.currentTime - dt
		
		local newScale = self.scale_progressbar
		newScale.x = 0.625 * ((120 - self.currentTime) / 120)

		gui.set_scale(self.progressbar, newScale)
		
		if self.currentTime <= 0 then
			-- fase boss
			
			self.currentTime = 120
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash('update_fragments') then
		print('ola')
		gui.set_text(self.lb_fragments, message.fragments)
	end
end

function on_input(self, action_id, action)
	if action_id == hash('touch') then
		handleTouch(self, action)
	end	
end

-- carrega dados da infobar
loadInfobar = function (self, currentStars, currentFragments, currentLife)
	gui.set_text(self.lb_stars, currentStars)
	gui.set_text(self.lb_fragments, currentFragments)
	gui.set_text(self.lb_life, currentLife)
end

-- carrega os planetas na sidebar
loadPlanetSidebar = function (self)
	for i = 1, self.numPlanetSidebar - 1 do
		local levels = playerdata.getAll(1).planets
		local planets = oyster.get('planetsdata').planets
		local img_planet = gui.get_node('img_planet' .. i)
		local lb_price_planet = gui.get_node('lb_price_planet' .. i)
		local frame = gui.get_node('planet' .. i)
		local idPlanet = self.planetsSelected[i]
		local idLevel = levels[idPlanet]

		gui.set_texture(img_planet, 'planet_sidebar')
		gui.play_flipbook(img_planet, 'planet' .. idPlanet)

		gui.set_texture(frame, 'frame')
		gui.play_flipbook(frame, 'frame' .. idLevel)
		
		gui.set_text(lb_price_planet, planets[idPlanet].status[idLevel].fragment)
	end
end
-- envia posicao dos portais
sendPosPortal = function (self)
	local portals = {}
	for i = 1, 5 do
		local pos = gui.get_screen_position(gui.get_node('portal' .. i))
		pos.x = pos.x - 80
		pos.y = pos.y - 55
		portals[i] = pos
	end

	msg.post('main:/main#game', 'update_portals', { portals = portals })
end

sendPosRoutes = function (self)
	local routes = {}
	for i = 1, 5 do
		local pos = gui.get_screen_position(gui.get_node('board' .. i .. '6'))
		pos.x = pos.x + 200 --2100
		routes[i] = pos
	end

	msg.post('main:/main#game', 'update_routes', { routes = routes })
end

updatePosPlanet = function (self, touch)
	if self.currentPlanetIndex then
		local pos = gui.get_position(self.currentPlanetSelect)
		gui.set_position(self.currentPlanetSelect, vmath.vector3(pos.x + touch.screen_dx, pos.y + touch.screen_dy, pos.z + 0))
	end
end

handleTouch = function (self, touch)
	-- atualiza posicao do planeta de acordo com o mouse
	updatePosPlanet(self, touch)
	
	if touch.pressed and not self.currentPlanetIndex then
		for i=1, self.numPlanetSidebar do
			if gui.pick_node(gui.get_node('planet' .. i), touch.x, touch.y) then
				self.currentPlanetSelect = gui.get_node('planet' .. i)
				self.currentPlanetIndex = i
				self.initialPosPlanet = gui.get_position(self.currentPlanetSelect)
			end
		end
		
	elseif touch.released and self.currentPlanetIndex then
		-- Planeta volta a posicao inicial
		gui.set_position(self.currentPlanetSelect, self.initialPosPlanet)

		-- envia comando de criar planeta
		for x = 1, self.boardLine do
			for y = 1, self.boardColumn  do
				local node = gui.get_node('board' .. x .. y)
				
				if gui.pick_node(node, touch.x, touch.y) then
					local pos = gui.get_screen_position(node)
					msg.post('main:/main#game', 'spawn_planet', { planetIndex = self.currentPlanetIndex, boardPosX = x, boardPosY = y, posWorld = pos })
				end
			end
		end
		
		self.currentPlanetIndex = nil
		self.currentPlanetSelect = nil
		self.initialPosPlanet = nil
	end
end 